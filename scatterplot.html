<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Interactive Scatterplot</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      margin: 0;
      background-color: white;
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s, color 0.3s;
    }

    .scatterplot-container {
      width: 100%;
      height: 100vh;
    }

    .tooltip {
      position: absolute;
      background-color: rgb(255, 255, 255);
      border: 1px solid black;
      padding: 5px;
      pointer-events: none;
      border-radius: 4px;
      transition: opacity 0.3s;
    }

    .dark-mode {
      background-color: #050505;
      color: #dbdbdb;
    }

    .dark-mode .tooltip {
      background-color: #333;
      color: #f0f0f0;
      border-color: #555;
    }

    /* Pareto curve styling */
    .pareto-curve {
      transition: opacity 0.3s ease;
    }

    .pareto-glow {
      transition: opacity 0.3s ease;
    }

    /* Control panel styling */
    .control-label {
      font-family: 'Poppins', sans-serif;
      font-size: 14px;
    }

    input[type="checkbox"] {
      accent-color: #10b981;
      transform: scale(1.1);
      cursor: pointer;
    }

    .toggle-dark-mode {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background-color: #007acc;
      color: rgb(255, 255, 255);
      border: none;
      padding: 8px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s, color 0.3s;
    }

    .dark-mode .toggle-dark-mode {
      background-color: #444;
    }

    /* Default dropdown style */
    select {
      font-family: 'Poppins', sans-serif;
      padding: 10px;
      font-size: 14px;
      border-radius: 5px;
      border: 1px solid #ccc;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      cursor: pointer;
    }

    /* Mobile specific styles */
    @media (max-width: 768px) {
      select {
        font-size: 16px;
        padding: 12px;
        width: 100%; /* Make dropdown take up full width */
      }
    }

    #category-toggle {
      font-family: 'Poppins', sans-serif;
      font-size: 14px;
      padding: 8px 30px 8px 12px; /* Extra right padding for arrow */
      width: 180px;
      border: 1px solid #ccc;
      border-radius: 8px; /* Soft rounded corners */
      background-color: white;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1); /* Subtle shadow */
      -webkit-appearance: none; /* Ensures styling works in all browsers */
      -moz-appearance: none;
      appearance: none;
      position: relative;
      margin-left: 5px;
    }

    /* Custom dropdown arrow (SVG) */
    #category-toggle {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 8px center; /* Moves arrow closer */
      background-size: 14px;
    }

    /* Remove blue outline */
    #category-toggle:focus,
    #category-toggle:active {
      outline: none !important;
      border-color: #aaa !important;
      box-shadow: none !important;
    }

    #arena-toggle {
      font-family: 'Poppins', sans-serif;
      font-size: 10px;
      padding: 8px 30px 8px 12px; /* Extra right padding for arrow */
      width: 100px;
      border: 1px solid #ccc;
      border-radius: 8px; /* Soft rounded corners */
      background-color: white;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1); /* Subtle shadow */
      -webkit-appearance: none; /* Ensures styling works in all browsers */
      -moz-appearance: none;
      appearance: none;
      position: relative;
      margin-left: 5px;
    }

    /* Custom dropdown arrow (SVG) */
    #arena-toggle {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black"><path d="M7 10l5 5 5-5z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 8px center; /* Moves arrow closer */
      background-size: 14px;
    }

    /* Remove blue outline */
    #arena-toggle:focus,
    #arena-toggle:active {
      outline: none !important;
      border-color: #aaa !important;
      box-shadow: none !important;
    }

    .info-tooltip {
      width: auto;
      min-width: 250px;
      max-width: 400px;
      white-space: normal; /* Allows text to wrap */
    }

    .org-filter-container {
      position: relative;
      display: inline-block;
    }

    .org-filter-dropdown {
      display: block;
      position: relative;
      top: 5px;
      left: 0;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 5px;
      padding: 10px;
      min-width: 180px;
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .org-filter-item {
      display: flex;
      align-items: center;
      padding: 5px;
      cursor: pointer;
      color: #f0f0f0;
      font-family: 'Poppins', sans-serif;
      font-size: 13px;
    }

    .org-filter-item:hover {
      background-color: #444;
    }

    .org-filter-item input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body class="dark-mode">
  <!-- Clean organized control bar -->
  <div id="control-bar" style="position: absolute; top: 0; left: 0; right: 0; padding: 10px 20px; z-index: 10; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 15px; background: rgba(5,5,5,0.9); border-bottom: 1px solid #333;">

    <!-- Left section: Data controls -->
    <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <label for="arena-toggle" style="font-family: 'Poppins', sans-serif; font-size: 13px; color: #aaa;">Arena:</label>
        <select id="arena-toggle" style="font-family: 'Poppins', sans-serif; padding: 5px 10px; font-size: 12px; border-radius: 5px; background: #222; color: #fff; border: 1px solid #444;">
          <option value="text">Language</option>
          <option value="vision">Vision</option>
          <option value="image">Text2Img</option>
        </select>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <label for="category-toggle" style="font-family: 'Poppins', sans-serif; font-size: 13px; color: #aaa;">Category:</label>
        <select id="category-toggle" style="font-family: 'Poppins', sans-serif; padding: 5px 10px; font-size: 12px; border-radius: 5px; background: #222; color: #fff; border: 1px solid #444;">
          <!-- Options will be populated dynamically -->
        </select>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <label style="font-family: 'Poppins', sans-serif; font-size: 13px; color: #aaa;">Cost:</label>
        <span style="font-size: 11px; color: #666;">Input</span>
        <input id="scale-slider" type="range" min="0" max="1" value="1" step="0.01" style="width: 80px; accent-color: #10b981;">
        <span style="font-size: 11px; color: #666;">Output</span>
      </div>
    </div>

    <!-- Center section: Pareto controls -->
    <div style="display: flex; align-items: center; gap: 20px; padding: 5px 15px; background: rgba(16,185,129,0.1); border-radius: 8px; border: 1px solid rgba(16,185,129,0.3);">
      <label style="font-family: 'Poppins', sans-serif; font-size: 13px; color: #10b981; font-weight: 600;">
        <input type="checkbox" id="pareto-checkbox" checked style="accent-color: #10b981;"> Pareto Frontier
      </label>

      <div style="display: flex; align-items: center; gap: 8px;">
        <label for="org-pareto-select" style="font-family: 'Poppins', sans-serif; font-size: 13px; color: #10b981;">Compare:</label>
        <select id="org-pareto-select" style="font-family: 'Poppins', sans-serif; padding: 5px 10px; font-size: 12px; border-radius: 5px; background: #1a3a2a; color: #10b981; border: 1px solid #10b981;">
          <option value="none">All Models</option>
          <!-- Will be populated dynamically -->
        </select>
      </div>
    </div>

    <!-- Right section: View controls -->
    <div style="display: flex; align-items: center; gap: 15px;">
      <label style="font-family: 'Poppins', sans-serif; font-size: 12px; color: #888;">
        <input type="checkbox" id="scatter-checkbox"> Style Control
      </label>
    </div>
  </div>

  <!-- Organization filter dropdown (positioned dynamically based on legend) -->
  <div id="org-filter-dropdown-container" class="org-filter-container" style="position: absolute; display: none; z-index: 1001;">
    <div class="org-filter-dropdown" id="org-filter-dropdown">
      <!-- Checkboxes will be populated dynamically -->
    </div>
  </div>
  <button class="toggle-dark-mode">Light Mode</button>
  <div id="scatterplot" class="scatterplot-container"></div>

  <script>
   const PUBLIC_DATA_PREFIX = "https://raw.githubusercontent.com/lmarena/arena-catalog/main/data"
   const LOCAL_DATA_PREFIX = "./data"
   const IS_LOCAL_DEV = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1"
   const URL_PREFIX = IS_LOCAL_DEV ? LOCAL_DATA_PREFIX : PUBLIC_DATA_PREFIX
   console.log(IS_LOCAL_DEV)

   // Configuration constants
   const SCORE_CUTOFF = 1305;  
   Promise.all([
        d3.json(`${URL_PREFIX}/scatterplot-data.json`),
        d3.json(`${URL_PREFIX}/leaderboard-text.json`),
        d3.json(`${URL_PREFIX}/visibility-data.json`),
        d3.json(`${URL_PREFIX}/leaderboard-text-style-control.json`),
        d3.json(`${URL_PREFIX}/leaderboard-vision.json`),
        d3.json(`${URL_PREFIX}/leaderboard-vision-style-control.json`),
        d3.json(`${URL_PREFIX}/leaderboard-image.json`)
      ]).then(function  ([data1, data2, data3, data4, data5, data6, data7]) {
      const slider = document.getElementById("scale-slider");

      // Define data booleans for renderScatterplot
      let styleControlOn = false;
      let arenaType = 'text';

      updateCategoryDropdown(arenaType, styleControlOn);
      const container = d3.select("#scatterplot");
      const svg = container.append("svg");
  
      const margin = { top: 70, right: 150, bottom: 100, left: 100 };
      
      const resize = () => {
        const width = container.node().clientWidth;
        const height = Math.min(container.node().clientHeight, (width / 8) * 5);;
        return { width, height };
      };

      const { width, height } = resize();
      window.addEventListener("resize", () => {
        const dimensions = resize();
        renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      // Custom brand colors for organizations - carefully chosen for distinction
      // Avoiding similar colors, ensuring visibility in both light/dark modes
      const orgBrandColors = {
        "Google": "#4285F4",        // Google Blue
        "OpenAI": "#00A67E",        // OpenAI Green (brightened)
        "Anthropic": "#E07A3E",     // Anthropic Orange (more saturated)
        "DeepSeek AI": "#1E90FF",   // DeepSeek - Dodger Blue (distinct from Google)
        "Meta": "#0866FF",          // Meta Blue
        "Alibaba": "#FF6A00",       // Alibaba Orange
        "01 AI": "#A855F7",         // Purple (distinct)
        "Amazon": "#FF9900",        // Amazon Orange
        "xAI": "#888888",           // xAI - Gray (Elon's X branding)
        "Z.ai": "#22D3EE",          // Cyan (distinct)
        "Tencent": "#00BE00",       // Tencent Green
        "Mistral": "#FF4500",       // Mistral - OrangeRed (distinct from other oranges)
        "Moonshot": "#C084FC",      // Light Purple (distinct from 01 AI)
        "Meituan": "#FFD000",       // Meituan Yellow
        "BF Labs": "#F5F5F5",       // Black Forest Labs - Light gray (visible on dark)
        "Luma AI": "#EC4899",       // Pink
        "Ideogram": "#14B8A6",      // Teal
        "Stability AI": "#7C3AED",  // Violet (distinct purple)
        "NexusFlow": "#06B6D4",     // Cyan
        "Other": "#9CA3AF"          // Medium Gray
      };

      // Create color scale with brand colors
      let colorScale = d3.scaleOrdinal()
        .domain(Object.keys(orgBrandColors))
        .range(Object.values(orgBrandColors));

      const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

      const selectedCategories = new Set();
      const hiddenOrganizations = new Set();

      // Function to populate organization filter dropdown
      function updateOrgFilter(organizations) {
        const dropdown = document.getElementById('org-filter-dropdown');
        dropdown.innerHTML = ''; // Clear existing

        // Add "Select All" / "Deselect All" option
        const selectAllDiv = document.createElement('div');
        selectAllDiv.className = 'org-filter-item';
        selectAllDiv.style.borderBottom = '1px solid #555';
        selectAllDiv.style.marginBottom = '5px';
        selectAllDiv.style.fontWeight = 'bold';
        selectAllDiv.innerHTML = `
          <input type="checkbox" id="org-select-all" ${hiddenOrganizations.size === 0 ? 'checked' : ''}>
          <label for="org-select-all">Select All</label>
        `;
        selectAllDiv.querySelector('input').addEventListener('change', (e) => {
          if (e.target.checked) {
            hiddenOrganizations.clear();
          } else {
            organizations.forEach(org => hiddenOrganizations.add(org));
          }
          renderScatterplot(resize().width, resize().height, styleControlOn, arenaType);
          updateOrgFilter(organizations);
        });
        dropdown.appendChild(selectAllDiv);

        // Add individual organization checkboxes
        organizations.forEach(org => {
          const div = document.createElement('div');
          div.className = 'org-filter-item';
          const isChecked = !hiddenOrganizations.has(org);
          div.innerHTML = `
            <input type="checkbox" id="org-${org.replace(/[^a-zA-Z0-9]/g, '-')}" ${isChecked ? 'checked' : ''}>
            <label for="org-${org.replace(/[^a-zA-Z0-9]/g, '-')}">${org}</label>
          `;
          div.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
              hiddenOrganizations.delete(org);
            } else {
              hiddenOrganizations.add(org);
            }
            renderScatterplot(resize().width, resize().height, styleControlOn, arenaType);
            updateOrgFilter(organizations);
          });
          dropdown.appendChild(div);
        });
      }

      // Update org Pareto dropdown with available organizations
      function updateOrgParetoDropdown(organizations) {
        const dropdown = document.getElementById('org-pareto-select');
        const currentValue = dropdown.value;

        // Clear existing options except "None"
        while (dropdown.options.length > 1) {
          dropdown.remove(1);
        }

        // Add organization options
        organizations.forEach(org => {
          const option = document.createElement('option');
          option.value = org;
          option.textContent = org;
          dropdown.appendChild(option);
        });

        // Restore previous selection if it still exists
        if (organizations.includes(currentValue)) {
          dropdown.value = currentValue;
        }
      }

      function calculatePointRadius(containerWidth, containerHeight) {
        return Math.max(3, Math.min(containerWidth / 210, 9, containerHeight/ 180));
      }

      function isParetoOptimal(point, data) {
        const price = parseFloat(point.input_token_price)  + slider.value * (point.output_token_price - point.input_token_price);
        const score = point[document.getElementById("category-toggle").value + "_rating"]
        for (const other of data) {
          const otherPrice = parseFloat(other.input_token_price) + slider.value * (other.output_token_price - other.input_token_price);
          const otherScore = other[document.getElementById("category-toggle").value + "_rating"]
          // Check if 'other' dominates 'point':
          // otherScore should be at least as good (>=) and otherPrice should be at most as good (<=)
          // with at least one strictly better condition.
          if (parseFloat(otherScore) >= parseFloat(score) &&
              parseFloat(otherPrice) <= parseFloat(price) &&
              (parseFloat(otherScore) > parseFloat(score) || parseFloat(otherPrice) < parseFloat(price))) {
              return false;
          }
        }
        return true;
      }

      // Compute Pareto frontier points for a dataset
      // Returns points sorted by price (descending) that form the efficient frontier
      function computeParetoFrontier(data, sliderValue, category) {
        // Get all Pareto optimal points
        const paretoPoints = data.filter(d => isParetoOptimal(d, data));

        // Sort by price descending (expensive to cheap, which is left to right on reversed axis)
        paretoPoints.sort((a, b) => {
          const priceA = parseFloat(a.input_token_price) + sliderValue * (a.output_token_price - a.input_token_price);
          const priceB = parseFloat(b.input_token_price) + sliderValue * (b.output_token_price - b.input_token_price);
          return priceB - priceA;
        });

        return paretoPoints;
      }

      // Compute Pareto frontier for a specific organization
      function computeOrgParetoFrontier(data, org, sliderValue, category) {
        const orgData = data.filter(d => d.legend_item === org);

        // For org-specific Pareto, we only compare within the org
        const paretoPoints = orgData.filter(point => {
          const price = parseFloat(point.input_token_price) + sliderValue * (point.output_token_price - point.input_token_price);
          const score = point[category + "_rating"];

          for (const other of orgData) {
            const otherPrice = parseFloat(other.input_token_price) + sliderValue * (other.output_token_price - other.input_token_price);
            const otherScore = other[category + "_rating"];

            if (parseFloat(otherScore) >= parseFloat(score) &&
                parseFloat(otherPrice) <= parseFloat(price) &&
                (parseFloat(otherScore) > parseFloat(score) || parseFloat(otherPrice) < parseFloat(price))) {
              return false;
            }
          }
          return true;
        });

        // Sort by price descending
        paretoPoints.sort((a, b) => {
          const priceA = parseFloat(a.input_token_price) + sliderValue * (a.output_token_price - a.input_token_price);
          const priceB = parseFloat(b.input_token_price) + sliderValue * (b.output_token_price - b.input_token_price);
          return priceB - priceA;
        });

        return paretoPoints;
      }

      // function determine if show label or not
  
      function renderScatterplot(w, h, styleControlOn, arenaType) {
        svg.selectAll("*").remove();
        
        let data = data1;
        // Assign legend item
        data.forEach(d => {
          const legendItems = arenaType == 'image' ? ["Google", "OpenAI", "Luma AI", "Ideogram", "Stability AI"] : ["Google", "OpenAI", "DeepSeek", "Anthropic", "Meta", "Alibaba", "01 AI", "Amazon", "xAI", "Z.ai", "Tencent", "Mistral", "Moonshot", "Meituan", "Other"];
          if (legendItems.includes(d.organization)) {
            d.legend_item = d.organization;
          } else if (d.organization == "Black Forest Labs") {
            d.legend_item = "BF Labs";
          } else {
            d.legend_item = "Other";
          }
        });

        // Get arena data
        const styleDataMapping = {
            text: data4,
            vision: data6
        };

        const noControlDataMapping = {
            text: data2,
            vision: data5,
            image: data7
        };

        let styleControlData = styleDataMapping[arenaType];
        let noControlData = noControlDataMapping[arenaType];
        let leaderboardData = styleControlOn ? styleControlData : noControlData;
        data.forEach(d => {
          Object.keys(leaderboardData).forEach(d2 => {
            if (d.model_api_name  in leaderboardData[d2]) {
              d[d2 + "_rating"] = leaderboardData[d2][d.model_api_name].rating;
              d[d2 + "_rating_q975"] = leaderboardData[d2][d.model_api_name].rating_q975;
              d[d2 + "_rating_q025"] = leaderboardData[d2][d.model_api_name].rating_q025;
              d[d2 + "_not_part_of_arena"] = false;
            } else {
              d[d2 + "_not_part_of_arena"] = true;
            }
          })
        });

        data = data.filter(d => d[document.getElementById("category-toggle").value + "_not_part_of_arena"] === false);

        // Filter out models below score cutoff
        const currentCategory = document.getElementById("category-toggle").value;
        data = data.filter(d => d[currentCategory + "_rating"] >= SCORE_CUTOFF);

        // Get all organizations BEFORE hiding any (for the filter dropdown)
        const desiredOrder = arenaType == "image" ? ["Google", "OpenAI", "BF Labs", "Luma AI", "Ideogram", "Stability AI"] : ["Google", "OpenAI", "DeepSeek", "Anthropic", "Meta", "Alibaba", "01 AI", "Amazon", "xAI", "Z.ai", "Tencent", "Mistral", "Moonshot", "Meituan", "Other"];
        const allOrganizations = [...new Set(data.map(d => d.legend_item))];
        const sortedAllOrgs = allOrganizations.sort((a, b) => {
            return desiredOrder.indexOf(a) - desiredOrder.indexOf(b);
        });
        updateOrgFilter(sortedAllOrgs);
        updateOrgParetoDropdown(sortedAllOrgs);

        // Filter out hidden organizations
        data = data.filter(d => !hiddenOrganizations.has(d.legend_item));

        // Filter out models with invalid/empty prices
        data = data.filter(d => d.input_token_price !== "" && d.output_token_price !== "" &&
                                !isNaN(parseFloat(d.input_token_price)) && !isNaN(parseFloat(d.output_token_price)));

        // Update the SVG size
        svg.attr("width", w).attr("height", h);

        // Get value from slider
        const value = slider.value;

        const minPrice = Math.min(...data.map(d => d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)));
        const maxPrice = Math.max(...data.map(d => d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)));

        const minFullRating = Math.min(...data.map(d => d[document.getElementById("category-toggle").value + "_rating_q025"]));
        const maxFullRating = Math.max(...data.map(d => d[document.getElementById("category-toggle").value + "_rating_q975"]));

        // Reversed X-axis: expensive on left, cheap on right (so top-right = best)
        const xScale = d3.scaleLog().domain([maxPrice*1.5, minPrice/2]).range([margin.left, width - margin.right]);
        const yScale = d3.scaleLinear().domain([minFullRating - 20, maxFullRating + 20]).range([height - margin.bottom, margin.top]);
    
        // Update the scales to use the new dimensions
        xScale.range([margin.left, w - margin.right]);
        yScale.range([h - margin.bottom, margin.top]);

        // Calculate dynamic font size (adjust as needed)
        const fontSize = Math.min(w, h) * 0.02; // Font size proportional to graph size
  
        // Add grid lines for x-axis
        svg.append("g")
          .attr("class", "x-grid")
          .selectAll("line")
          .data(xScale.ticks(10))
          .join("line")
          .attr("x1", d => xScale(d))
          .attr("x2", d => xScale(d))
          .attr("y1", margin.top)
          .attr("y2", h - margin.bottom)
          .attr("stroke", "#ccc")
          .attr("stroke-width", 1)
          .attr("stroke-opacity", document.body.classList.contains("dark-mode") ? 0.1 : 0.2);  // Lower opacity in dark mode
  
        // Add grid lines for y-axis
        svg.append("g")
          .attr("class", "y-grid")
          .selectAll("line")
          .data(yScale.ticks(10))
          .join("line")
          .attr("y1", d => yScale(d))
          .attr("y2", d => yScale(d))
          .attr("x1", margin.left)
          .attr("x2", w - margin.right)
          .attr("stroke", "#ccc")
          .attr("stroke-width", 1)
          .attr("stroke-opacity", document.body.classList.contains("dark-mode") ? 0.1 : 0.2);  // Lower opacity in dark mode
  
        // Add x-axis
        svg.append("g")
          .attr("transform", `translate(0,${h - margin.bottom})`)
          .call(d3.axisBottom(xScale).ticks(10, ","))
          .selectAll("text")
          .style("font-family", "Poppins")
          .style("font-size", `${fontSize}px`); // Set dynamic font size
  
        // Add y-axis
        svg.append("g")
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(yScale))
          .selectAll("text")
          .style("font-family", "Poppins")
          .style("font-size", `${fontSize}px`); // Set dynamic font size
          
        // Add legend title with filter functionality
        const legendTitleGroup = svg.append("g")
          .attr("class", "legend-title-group")
          .style("cursor", "pointer");

        legendTitleGroup.append("text")
          .attr("class", "legend-title")
          .attr("x", w - 0.75*margin.right)
          .attr("y", margin.top + 30)
          .style("text-anchor", "middle")
          .style("font-family", "Poppins")
          .style("font-weight", "bold")
          .style("fill", document.body.classList.contains("dark-mode") ? "#fff" : "#000")
          .style("font-size", `${fontSize + 1}px`)
          .text("Organization");

        // Add dropdown indicator next to title
        legendTitleGroup.append("text")
          .attr("class", "legend-filter-icon")
          .attr("x", w - 0.75*margin.right + 60)
          .attr("y", margin.top + 27)
          .style("font-family", "Poppins")
          .style("font-size", `${fontSize}px`)
          .style("fill", "#aaa")
          .text("⌵"); // Dropdown indicator

        // Position and show/hide dropdown on hover
        const dropdownContainer = document.getElementById('org-filter-dropdown-container');
        const legendTitleX = w - 0.75*margin.right;
        const legendTitleY = margin.top + 30;

        legendTitleGroup.on("mouseenter", () => {
          // Position dropdown to the left so it stays within viewport
          dropdownContainer.style.left = `${legendTitleX - 90}px`;
          dropdownContainer.style.top = `${legendTitleY + 10}px`;
          dropdownContainer.style.display = 'block';
        });

        dropdownContainer.addEventListener('mouseenter', () => {
          dropdownContainer.style.display = 'block';
        });

        dropdownContainer.addEventListener('mouseleave', () => {
          dropdownContainer.style.display = 'none';
        });

        legendTitleGroup.on("mouseleave", () => {
          // Small delay to allow moving to dropdown
          setTimeout(() => {
            if (!dropdownContainer.matches(':hover')) {
              dropdownContainer.style.display = 'none';
            }
          }, 100);
        });
        
        // Add x-axis title with arrow indicating "cheaper →"
        svg.append("text")
          .attr("class", "x-axis-title")
          .attr("x", w / 2)
          .attr("y", h - margin.bottom / 3)
          .attr("text-anchor", "middle")
          .style("font-family", "Poppins")
          .style("fill", document.body.classList.contains("dark-mode") ? "#fff" : "#000")
          .style("font-size", `${fontSize * 1.2}px`)
          .text(arenaType === "image" ? "← Expensive · Cost ($/Image) · Cheaper →" : "← Expensive · Cost ($/1M Tokens) · Cheaper →");

        // Add y-axis title
        svg.append("text")
          .attr("class", "y-axis-title")
          .attr("x", -h / 2)
          .attr("y", margin.left / 3)
          .attr("transform", "rotate(-90)")
          .attr("text-anchor", "middle")
          .style("font-family", "Poppins")
          .style("fill", document.body.classList.contains("dark-mode") ? "#fff" : "#000")
          .style("font-size", `${fontSize * 1.2}px`)
          .text("Arena Score");

        svg.append("text")
          .attr("class", "watermark")
          .attr("x", w - 150)            // 10px from the right edge
          .attr("y", h - 130)            // 10px from the bottom edge
          .attr("text-anchor", "end")   // Right-align the text
          .style("font-family", "Poppins")
          .style("font-size", `${fontSize * 2.5}px`)
          .style("fill", document.body.classList.contains("dark-mode") ? "#aaa" : "#000")
          .style("opacity", 0.5)
          .text("lmarena.ai/price");


        // Get visible categories for legend (after filtering hidden orgs)
        const categories = [...new Set(data.map(d => d.legend_item))];
        const sortedCategories = categories.sort((a, b) => {
            return desiredOrder.indexOf(a) - desiredOrder.indexOf(b);
        });

        // Pre-populate color scale to lock in color assignments based on ALL organizations (for consistent colors)
        sortedAllOrgs.forEach(cat => colorScale(cat));
       
        const legend = svg.append("g")
          .attr("transform", `translate(${w - margin.right}, ${margin.top + 40})`)
          .selectAll(".legend-item")
          .data(sortedCategories)
          .join("g")
          .attr("class", "legend-item")
          .attr("transform", (d, i) => `translate(0, ${i * 20})`)
          .style("cursor", "pointer")
          .on("mouseover", (_, category) => {
            groups
                .style("opacity", d => selectedCategories.has(d.legend_item) || d.legend_item === category ? 1 : 0.1)
                .style("stroke-width", d => d.legend_item === category ? 2 : null);
  
            labels
                .style("opacity", d => selectedCategories.has(d.legend_item) || d.legend_item === category ? 1 : 0);
  
            legend.selectAll("rect")
                .style("opacity", d => selectedCategories.has(d) || d === category ? 1 : 0.1);
            legend.selectAll("text")
                .style("opacity", d => selectedCategories.has(d) || d === category ? 1 : 0.1);
          })
          .on("mouseout", () => {
            groups
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0.1)
                .style("stroke", null)
                .style("stroke-width", null);
  
            labels
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0);
  
            legend.selectAll("rect")
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d) ? 1 : 0.1);
            legend.selectAll("text")
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d) ? 1 : 0.1);
          })
          .on("click", (_, category) => {
            if (selectedCategories.has(category)) {
                selectedCategories.delete(category);
            } else {
                selectedCategories.add(category);
            }
  
            if (selectedCategories.size === categories.length) {
                selectedCategories.clear();
            }
  
            groups
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0.1);
  
            labels
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0);
  
            legend.selectAll("rect")
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d) ? 1 : 0.1);
            legend.selectAll("text")
                .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d) ? 1 : 0.1);
          });

          // Draw Pareto frontier curve
          const showPareto = document.getElementById("pareto-checkbox").checked;
          const paretoPoints = computeParetoFrontier(data, value, currentCategory);

          if (showPareto && paretoPoints.length > 1) {
            // Create stepped line path data for the Pareto frontier
            // With reversed axis: we go from expensive (left) to cheap (right)
            // The stepped line shows: "at this price or cheaper, this is the best score"
            const paretoPathData = [];

            for (let i = 0; i < paretoPoints.length; i++) {
              const d = paretoPoints[i];
              const price = parseFloat(d.input_token_price) + value * (d.output_token_price - d.input_token_price);
              const score = d[currentCategory + "_rating"];

              if (i === 0) {
                // Start from the top of the chart at the first (most expensive) point's x
                paretoPathData.push({ x: price, y: maxFullRating + 20 });
                paretoPathData.push({ x: price, y: score });
              } else {
                // Step right then down (or stay at same level)
                const prevD = paretoPoints[i - 1];
                const prevScore = prevD[currentCategory + "_rating"];
                paretoPathData.push({ x: price, y: prevScore });
                paretoPathData.push({ x: price, y: score });
              }
            }

            // Extend to the right edge (cheapest)
            if (paretoPoints.length > 0) {
              const lastD = paretoPoints[paretoPoints.length - 1];
              const lastPrice = parseFloat(lastD.input_token_price) + value * (lastD.output_token_price - lastD.input_token_price);
              const lastScore = lastD[currentCategory + "_rating"];
              paretoPathData.push({ x: minPrice / 2, y: lastScore });
            }

            // Draw the Pareto curve line
            const paretoLine = d3.line()
              .x(d => xScale(d.x))
              .y(d => yScale(d.y));

            svg.append("path")
              .attr("class", "pareto-curve")
              .attr("d", paretoLine(paretoPathData))
              .attr("fill", "none")
              .attr("stroke", "#10b981")  // Green color for efficiency frontier
              .attr("stroke-width", 2.5)
              .attr("stroke-dasharray", "8,4")
              .attr("opacity", 0.8);

            // Add shaded area below the Pareto curve (dominated region hint)
            const areaPathData = [...paretoPathData];
            // Close the path by going to bottom-right corner then back to start
            areaPathData.push({ x: minPrice / 2, y: minFullRating - 20 });
            areaPathData.push({ x: paretoPathData[0].x, y: minFullRating - 20 });
            areaPathData.push(paretoPathData[0]);

            svg.insert("path", ":first-child")
              .attr("class", "pareto-area")
              .attr("d", paretoLine(areaPathData))
              .attr("fill", "#10b981")
              .attr("opacity", 0.05);

            // Add "Pareto Frontier" label in top-right of CHART area (left of legend)
            // Legend starts at w - margin.right, so position label with enough gap
            const paretoLabelBoxX = w - margin.right - 250;
            const labelBoxY = margin.top + 5;

            // Background box for label
            svg.append("rect")
              .attr("class", "pareto-label-bg")
              .attr("x", paretoLabelBoxX - 8)
              .attr("y", labelBoxY - 5)
              .attr("width", 200)
              .attr("height", 48)
              .attr("rx", 5)
              .attr("fill", document.body.classList.contains("dark-mode") ? "rgba(16, 185, 129, 0.12)" : "rgba(16, 185, 129, 0.1)")
              .attr("stroke", "#10b981")
              .attr("stroke-width", 1.5)
              .attr("stroke-dasharray", "4,2");

            svg.append("text")
              .attr("class", "pareto-label")
              .attr("x", paretoLabelBoxX)
              .attr("y", labelBoxY + 15)
              .style("font-family", "Poppins")
              .style("font-size", `${fontSize * 1.05}px`)
              .style("fill", "#10b981")
              .style("font-weight", "700")
              .text("▶ Pareto Frontier");

            svg.append("text")
              .attr("class", "pareto-sublabel")
              .attr("x", paretoLabelBoxX)
              .attr("y", labelBoxY + 33)
              .style("font-family", "Poppins")
              .style("font-size", `${fontSize * 0.75}px`)
              .style("fill", "#10b981")
              .style("opacity", 0.8)
              .text("Best model at each price →");
          }

          // Draw organization-specific Pareto curve
          const selectedOrg = document.getElementById("org-pareto-select").value;
          if (selectedOrg !== "none") {
            const orgParetoPoints = computeOrgParetoFrontier(data, selectedOrg, value, currentCategory);
            const orgColor = colorScale(selectedOrg);

            if (orgParetoPoints.length > 1) {
              const orgParetoPathData = [];

              for (let i = 0; i < orgParetoPoints.length; i++) {
                const d = orgParetoPoints[i];
                const price = parseFloat(d.input_token_price) + value * (d.output_token_price - d.input_token_price);
                const score = d[currentCategory + "_rating"];

                if (i === 0) {
                  orgParetoPathData.push({ x: price, y: maxFullRating + 20 });
                  orgParetoPathData.push({ x: price, y: score });
                } else {
                  const prevD = orgParetoPoints[i - 1];
                  const prevScore = prevD[currentCategory + "_rating"];
                  orgParetoPathData.push({ x: price, y: prevScore });
                  orgParetoPathData.push({ x: price, y: score });
                }
              }

              // Extend to the right edge
              if (orgParetoPoints.length > 0) {
                const lastD = orgParetoPoints[orgParetoPoints.length - 1];
                const lastScore = lastD[currentCategory + "_rating"];
                orgParetoPathData.push({ x: minPrice / 2, y: lastScore });
              }

              const orgParetoLine = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y));

              svg.append("path")
                .attr("class", "org-pareto-curve")
                .attr("d", orgParetoLine(orgParetoPathData))
                .attr("fill", "none")
                .attr("stroke", orgColor)
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "4,2")
                .attr("opacity", 0.9);

              // Add org Pareto label below the main Pareto label (top-right chart area)
              const orgLabelBoxX = w - margin.right - 250;
              const orgLabelBoxY = showPareto ? margin.top + 58 : margin.top + 5;

              svg.append("rect")
                .attr("class", "org-pareto-label-bg")
                .attr("x", orgLabelBoxX - 5)
                .attr("y", orgLabelBoxY - 3)
                .attr("width", 190)
                .attr("height", 24)
                .attr("rx", 5)
                .attr("fill", document.body.classList.contains("dark-mode") ? "rgba(0,0,0,0.6)" : "rgba(255,255,255,0.9)")
                .attr("stroke", orgColor)
                .attr("stroke-width", 1.5)
                .attr("stroke-dasharray", "4,2");

              svg.append("text")
                .attr("class", "org-pareto-label")
                .attr("x", orgLabelBoxX)
                .attr("y", orgLabelBoxY + 13)
                .style("font-family", "Poppins")
                .style("font-size", `${fontSize * 0.9}px`)
                .style("fill", orgColor)
                .style("font-weight", "600")
                .text(`▶ ${selectedOrg} Frontier`);
            }
          }

          // Calculate label positions with collision detection
          const labelData = data.map(d => {
            const price = d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price);
            const pointX = xScale(price);
            const pointY = yScale(d[currentCategory + "_rating"]);
            const isPareto = isParetoOptimal(d, data);
            const isInVisibilityList = data3[currentCategory]["right"].includes(d.model_api_name) ||
                                       data3[currentCategory]["left"].includes(d.model_api_name);

            // Determine if label should be shown (Pareto optimal or in visibility list)
            const shouldShow = isPareto || isInVisibilityList;

            // Determine label side (left or right of point)
            const labelOnRight = price >= maxPrice*0.7 || data3[currentCategory].left.includes(d.model_api_name);

            // Estimate label width based on name length
            const labelWidth = d.name.length * fontSize * 0.6;
            const labelHeight = fontSize * 1.2;

            const labelX = labelOnRight ? pointX + 0.01*w : pointX - 0.01*w;
            const labelY = pointY + 0.003*w;

            return {
              ...d,
              pointX,
              pointY,
              labelX,
              labelY,
              labelOnRight,
              labelWidth,
              labelHeight,
              shouldShow,
              isPareto,
              visible: shouldShow  // Will be updated by collision detection
            };
          });

          // Sort by priority: Pareto optimal first, then by score
          labelData.sort((a, b) => {
            if (a.isPareto && !b.isPareto) return -1;
            if (!a.isPareto && b.isPareto) return 1;
            return b[currentCategory + "_rating"] - a[currentCategory + "_rating"];
          });

          // Collision detection - hide labels that overlap with higher priority labels
          const placedLabels = [];
          const padding = 4;

          labelData.forEach(label => {
            if (!label.shouldShow) {
              label.visible = false;
              return;
            }

            // Calculate bounding box
            const bbox = {
              x: label.labelOnRight ? label.labelX : label.labelX - label.labelWidth,
              y: label.labelY - label.labelHeight,
              width: label.labelWidth,
              height: label.labelHeight
            };

            // Check if within chart bounds
            if (bbox.x < margin.left || bbox.x + bbox.width > w - margin.right ||
                bbox.y < margin.top || bbox.y + bbox.height > h - margin.bottom) {
              label.visible = false;
              return;
            }

            // Check for collisions with already placed labels
            const hasCollision = placedLabels.some(placed => {
              return !(bbox.x + bbox.width + padding < placed.x ||
                       bbox.x > placed.x + placed.width + padding ||
                       bbox.y + bbox.height + padding < placed.y ||
                       bbox.y > placed.y + placed.height + padding);
            });

            if (hasCollision) {
              // Try alternate position (opposite side)
              const altLabelX = label.labelOnRight ? label.pointX - 0.01*w : label.pointX + 0.01*w;
              const altBbox = {
                x: label.labelOnRight ? altLabelX - label.labelWidth : altLabelX,
                y: label.labelY - label.labelHeight,
                width: label.labelWidth,
                height: label.labelHeight
              };

              const altHasCollision = placedLabels.some(placed => {
                return !(altBbox.x + altBbox.width + padding < placed.x ||
                         altBbox.x > placed.x + placed.width + padding ||
                         altBbox.y + altBbox.height + padding < placed.y ||
                         altBbox.y > placed.y + placed.height + padding);
              });

              if (!altHasCollision && altBbox.x >= margin.left && altBbox.x + altBbox.width <= w - margin.right) {
                label.labelX = altLabelX;
                label.labelOnRight = !label.labelOnRight;
                placedLabels.push(altBbox);
                label.visible = true;
              } else {
                label.visible = false;
              }
            } else {
              placedLabels.push(bbox);
              label.visible = true;
            }
          });

          const labels = svg.selectAll(".point-label").data(labelData.filter(d => d.visible)).join("text")
            .attr("class", "point-label")
            .attr("x", d => d.labelX)
            .attr("y", d => d.labelY)
            .attr("text-anchor", d => d.labelOnRight ? "start" : "end")
            .style("font-size", `${fontSize}px`)
            .attr("font-family", "Poppins")
            .style("text-decoration", d => d.isPareto ? "underline" : "none")
            .style("font-weight", d => d.isPareto ? "600" : "normal")
            .attr("fill", document.body.classList.contains("dark-mode") ? "#f0f0f0" : "#000000")
            .style("opacity", 1)
            .text(d => d.name);

        const pointRadius = calculatePointRadius(w, h);

        const groups = svg.selectAll(".point-group")
          .data(data)
          .join("g")
          .attr("class", "point-group");
        
        // Add vertical error bars
        const errorBarTops = groups.append("line")
          .attr("class", "error-bar-top")
          .attr("x1", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price))) // Centered on the x position of the point
          .attr("x2", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)))
          .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q975"])) // Upper bound
          .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) - pointRadius) // Lower bound
          .attr("stroke", d => colorScale(d.legend_item))
          .attr("stroke-width", 1)
          .style("display", "none"); // Hide by default

        const errorBarBottoms = groups.append("line")
          .attr("class", "error-bar-bottom")
          .attr("x1", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price))) // Centered on the x position of the point
          .attr("x2", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)))
          .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) + pointRadius) // Upper bound
          .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q025"])) // Lower bound
          .attr("stroke", d => colorScale(d.legend_item))
          .attr("stroke-width", 1)
          .style("display", "none"); // Hide by default

        // Add horizontal caps for the top of the error bars
        const horizontalTopCaps = groups.append("line")
          .attr("class", "error-bar-cap-top")
          .attr("x1", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)) - 5) // Slightly left of the point
          .attr("x2", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)) + 5) // Slightly right of the point
          .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q975"])) // Same y as the top of the error bar
          .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q975"]))
          .attr("stroke", d => colorScale(d.legend_item))
          .attr("stroke-width", 1)
          .style("display", "none"); // Hide by default

        // Add horizontal caps for the bottom of the error bars
        const horizontalBottomCaps = groups.append("line")
          .attr("class", "error-bar-cap-bottom")
          .attr("x1", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)) - 5) // Slightly left of the point
          .attr("x2", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)) + 5) // Slightly right of the point
          .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q025"])) // Same y as the bottom of the error bar
          .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating_q025"]))
          .attr("stroke", d => colorScale(d.legend_item))
          .attr("stroke-width", 1)
          .style("display", "none"); // Hide by default
        
        // Add glow effect for Pareto-optimal points
        const paretoGlow = groups.filter(d => isParetoOptimal(d, data))
          .append("circle")
          .attr("class", "pareto-glow")
          .attr("cx", d => xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)))
          .attr("cy", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]))
          .attr("r", pointRadius + 8)
          .attr("fill", "#10b981")
          .style("opacity", showPareto ? 0.25 : 0)
          .style("filter", "blur(3px)");

        // Determine stroke color based on mode for visibility
        const isDarkMode = document.body.classList.contains("dark-mode");
        const defaultStroke = isDarkMode ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.8)";

        const points = groups.append("circle")
          .attr("class", "point")
          .attr("cx", function(d) { return xScale(d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)); })
          .attr("cy", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]))
          .attr("r", d => isParetoOptimal(d, data) && showPareto ? pointRadius + 4 : pointRadius + 2)
          .attr("fill", d => colorScale(d.legend_item))
          .attr("stroke", d => isParetoOptimal(d, data) && showPareto ? "#10b981" : defaultStroke)
          .attr("stroke-width", d => isParetoOptimal(d, data) && showPareto ? 2.5 : 1)
          .style("opacity", 1)
          .style("display", "block")
          .on("mouseover", (event, d) => {
            d3.select(event.currentTarget)
              .attr("r", showConfidenceIntervals ? pointRadius + 2 : pointRadius + 4)
            
            // Adjust error bars
            errorBarTops
              .filter((e) => e === d) // Select only the error bars for the hovered point
              .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) - (pointRadius + 2));  // Update error bars for expanded radius
            
            errorBarBottoms
              .filter((e) => e === d) // Select only the error bars for the hovered point
              .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) + (pointRadius + 2));  // Update error bars for expanded radius

            d3.select(event.currentTarget)
              .style("opacity", 1);
  
            groups
              .filter(other => other !== d)
              .style("opacity", 0.1);
  
            labels
              .filter(other => other !== d)
              .style("opacity", 0);
  
            let tooltipX = event.pageX + 0.07*w;
            let tooltipY = event.pageY - 0.1*w;
  
            if (event.pageX > w*0.5) {
              tooltipX = event.pageX - 0.16*w;
            }
  
            if (event.pageY < h*0.5) {
              tooltipY = event.pageY + 0.05*w;
            }
            
            tooltip.style("opacity", 1)
              .html(`<b>${d.model_api_name}</b><br>
                      Arena Score: ${parseFloat(d[document.getElementById("category-toggle").value + "_rating"]).toFixed(2)}<br>
                      ${arenaType == "image" ? 'Cost ($/Image)' : 'Cost ($/1M Tokens)'}: ${d.input_token_price*1.0 + value * (d.output_token_price - d.input_token_price)}<br>
                      Organization: ${d.organization}<br>
                      License: ${d.license}`)
              .style("left", `${tooltipX}px`)
              .style("top", `${tooltipY}px`)
              .style("font-size", `${fontSize * 0.85}px`);
  
            legend.filter(l => l !== d.legend_item && (selectedCategories.size === 0 || selectedCategories.has(l))).style("opacity", 0.1);
          })
          .on("mouseout", () => {
            d3.select(event.currentTarget)
              .attr("r", showConfidenceIntervals ? pointRadius : pointRadius + 2);

            // Reset error bars
            errorBarTops
              .attr("y2", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) - pointRadius);  // Reset error bars
            
            // Reset error bars
            errorBarBottoms
              .attr("y1", d => yScale(d[document.getElementById("category-toggle").value + "_rating"]) + pointRadius);  // Reset error bars

            groups
              .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0.1);
  
            labels
              .style("opacity", d => selectedCategories.size === 0 || selectedCategories.has(d.legend_item) ? 1 : 0);
  
            tooltip.style("opacity", 0);
            legend.filter(l => selectedCategories.size === 0 || selectedCategories.has(l)).style("opacity", 1);
          })
          .on("click", (event, d) => {
            // Navigate to the link associated with the data point
            if (d.model_source) {
              window.open(d.model_source, "_blank"); // Opens the link in a new tab
            }
        });
        
        // Initial state
        let showConfidenceIntervals = false; 

        // Create a toggle container (group)
        const toggleGroup = svg.append("g")
          .attr("class", "toggle-group")
          .attr("transform", `translate(${w - margin.right - 340}, 20)`)
          .style("cursor", "pointer");
        const toggleBackground = toggleGroup.append("rect")
          .attr("width", 40)
          .attr("height", 20)
          .attr("y", -5)
          .attr("rx", 10) // Rounded edges
          .attr("fill", showConfidenceIntervals ? "#4caf50" : "#ccc") // Green if ON, gray if OFF
        const toggleCircle = toggleGroup.append("circle")
          .attr("cx", showConfidenceIntervals ? 30 : 10) // Position depends on state
          .attr("cy", 5)
          .attr("r", 8)
          .attr("fill", "#fff");

        // Toggle click interaction
        toggleGroup.on("click", function() {
          showConfidenceIntervals = !showConfidenceIntervals; // Toggle state

          // Update switch background color
          toggleBackground.attr("fill", showConfidenceIntervals ? "#4caf50" : "#ccc");

          // Move the circle
          toggleCircle.transition().duration(200)
            .attr("cx", showConfidenceIntervals ? 30 : 10);

          // Update confidence interval visibility
          d3.selectAll(".error-bar-top, .error-bar-bottom, .error-bar-cap-top, .error-bar-cap-bottom")
            .style("display", showConfidenceIntervals ? "block" : "none");

          // Update point radius
          points.attr("r", showConfidenceIntervals ? pointRadius : pointRadius + 2);
        });

        legend.append("rect")
          .attr("width", pointRadius*3.2)
          .attr("height", pointRadius*3.2)
          .attr("fill", d => colorScale(d))
          .style("opacity", 1);
  
        legend.append("text")
          .attr("x", 20)
          .attr("y", 12)
          .style("font-family", "Poppins")
          .style("font-size", `${fontSize + 1}px`)
          .style("fill", document.body.classList.contains("dark-mode") ? "#f0f0f0" : "#000000")
          .text(d => d);
      }

      // Re-render scatterplot on category change
      document.getElementById("category-toggle").addEventListener("change", () => {
        const dimensions = resize();
        renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      // Re-render scatterplot on scale change
      slider.addEventListener("input", function() {
        const dimensions = resize();
        renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      renderScatterplot(width, height, styleControlOn, arenaType);

      function updateSliderColor() {
        const slider = document.getElementById("scale-slider");
        const isDarkMode = document.body.classList.contains("dark-mode");

        slider.style.accentColor = isDarkMode ? "white" : "black";
      }

      function sortKeys(keys, orderKeys) {
        sortedKeys = keys.sort((a, b) => {
            // First, check the position in the custom order array
            const aIndex = orderKeys.indexOf(a);
            const bIndex = orderKeys.indexOf(b);

            // If both keys are found in the custom order, compare their indices
            if (aIndex !== -1 && bIndex !== -1) {
              return aIndex - bIndex;
            }

            // If one of the keys is not in the custom order, keep its relative position
            if (aIndex === -1 && bIndex === -1) return 0;
            return aIndex === -1 ? 1 : -1;
        });
        return sortedKeys;
      }

      function updateCategoryDropdown(arenaType, styleControlOn) {
        const dropdown = d3.select("#category-toggle");

        // Remove existing options
        dropdown.selectAll("option").remove();
        
        // Get all keys from the JSON
        const styleDataMapping = {
            text: data4,
            vision: data6
        };

        const noControlDataMapping = {
            text: data2,
            vision: data5,
            image: data7
        };
        let styleControlData = styleDataMapping[arenaType];
        let noControlData = noControlDataMapping[arenaType];
        let leaderboardData = styleControlOn ? styleControlData : noControlData;
        let allKeys = Object.keys(leaderboardData);
        
        const orderTextKeys = ['full', 'math', 'if', 'multiturn', 'creative_writing', 'coding', 'hard_6', 'hard_english_6', 'long_user', 'english', 'chinese', 'french', 'german', 'spanish', 'russian', 'japanese', 'korean', 'no_tie', 'no_short', 'no_refusal']
        const orderVisionKeys = ['full', 'english', 'chinese']
        const orderTxt2ImageKeys = ['full', 'not_preset_generation', 'is_preset_generation']
        
        
        const keyMapping = {
            text: orderTextKeys,
            vision: orderVisionKeys,
            image: orderTxt2ImageKeys
        };
        const orderKeys = keyMapping[arenaType];
        sortKeys(allKeys, orderKeys);

        // Function to format key names
        const formatKey = (key) => {
          const keyMapping = {
            if: "Instruction Following",
            multiturn: "Multi-Turn",
            hard_6: "Hard Prompts",
            hard_english_6: "Hard Prompts (English)",
            long_user: "Longer Query",
            no_tie: "Exclude Ties",
            no_short: "Exclude Short Query",
            not_preset_generation: "User Prompts Only",
            is_preset_generation: "Pre-generated Prompts"
          };

          return keyMapping[key] || key
            .replace(/_/g, " ")  // Replace underscores with spaces
            .replace(/\b\w/g, char => char.toUpperCase()); // Capitalize each word;
        };

        // Append each key as an option
        allKeys.forEach(key => {
          dropdown
            .append("option")
            .attr("value", key)
            .text(key === "full" ? "Overall" : formatKey(key));
        });
      }

       // Re-render scatterplot on arena change
       d3.select("#arena-toggle").on("change", function() {
        arenaType = this.value;
        updateCategoryDropdown(arenaType, styleControlOn);

        // Update style control checkbox 
        var checkbox = document.getElementById("scatter-checkbox");
        if (this.value === "image") {
            checkbox.disabled = true;
        } else {
            checkbox.disabled = false;
        }
        var slider = document.getElementById("scale-slider");
        var tooltip = document.querySelector('.info-tooltip');

        // Update price slider
        if (this.value === "image") {
            slider.disabled = true;
            tooltip.innerHTML = "The cost ratio slider is disabled for text2img.";
        } else {
            slider.disabled = false;
            tooltip.innerHTML = "Use this slider to adjust the input/output cost ratio of the x-axis. Sliding it to the left shows the cost in <b>$/1M Input Tokens</b>. Sliding it to the right shows the cost in <b>$/1M Output Tokens</b>. Placing it in the middle displays a blended cost based on both values.";
        }

        // Reset color scale to brand colors
        colorScale = d3.scaleOrdinal()
          .domain(Object.keys(orgBrandColors))
          .range(Object.values(orgBrandColors));

        const dimensions = resize();
        renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      // Function to handle checkbox change
      d3.select("#scatter-checkbox").on("change", function() {
          styleControlOn = this.checked; // Update state
          if (arenaType == 'vision') {
            updateCategoryDropdown(arenaType, styleControlOn);
          }
          // Re-render scatterplot with updated colors
          const dimensions = resize();
          renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      // Function to handle Pareto checkbox change
      d3.select("#pareto-checkbox").on("change", function() {
          const dimensions = resize();
          renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      // Function to handle org Pareto dropdown change
      d3.select("#org-pareto-select").on("change", function() {
          const dimensions = resize();
          renderScatterplot(dimensions.width, dimensions.height, styleControlOn, arenaType);
      });

      document.querySelector(".toggle-dark-mode").addEventListener("click", () => {
        const body = document.body;
        const isDarkMode = body.classList.toggle("dark-mode");
        updateSliderColor();
  
        const button = document.querySelector(".toggle-dark-mode");
        button.textContent = isDarkMode ? "Light Mode" : "Dark Mode";
  
        svg.selectAll(".point-label")
          .attr("fill", isDarkMode ? "#f0f0f0" : "#000000");
        
        svg.selectAll(".error-bar-box")
          .attr("stroke", isDarkMode ? "#f0f0f0" : "#000000")
  
        svg.selectAll(".legend-item text")
          .style("fill", isDarkMode ? "#f0f0f0" : "#000000");
  
        svg.selectAll(".x-grid line, .y-grid line")
          .attr("stroke-opacity", isDarkMode ? 0.1 : 0.2);

        svg.selectAll(".x-axis-title, .y-axis-title, .legend-title")
          .style("fill", isDarkMode ? "#fff" : "#000");
      });
    });
  </script>  
</body>
</html>
